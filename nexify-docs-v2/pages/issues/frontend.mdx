Clinical Canvas Frontend Codebase Analysis
Overview of Current Structure and Issues

The Clinical Canvas React frontend is functional but exhibits organizational issues that can hinder maintainability and onboarding. Currently, files are split by type (pages vs. components) rather than grouped by feature. This has led to duplicate code (multiple files for similar purposes) and some unused legacy code lingering in the repository. For example, there are two versions of the “Add Patient” page and form components doing nearly the same thing
GitHub
GitHub
. Similarly, “Add” and “Edit” pages for tasks, medications, and notes repeat a lot of the same form UI and logic. These redundancies and the scattered structure can confuse new developers (especially those without frontend experience) and make the code harder to maintain.

Below, we detail the specific issues and recommend a clearer, feature-based organization. By restructuring and removing unused parts, the code will be easier to understand and extend.

High-Level Issues

Mixed Organization: The codebase isn’t consistently organized. It uses some atomic design ideas (shared UI components in components/ui and layout components) but domain-specific code is split across src/pages and src/components. A more feature-oriented structure (grouping related pages, components, and logic by feature/module) would make it more intuitive. For instance, patient-related pages and components are not in one place but scattered in pages, components, and even a new features folder.

Duplicate & Redundant Code: There are multiple files implementing the same or very similar functionality. This includes separate files for adding and editing the same entity (patients, tasks, notes, etc.), as well as old vs. new versions of forms. Maintaining duplicate code means any change or bug fix might need to be repeated in several places. It also increases bundle size and cognitive load.

Unused Legacy Code: Some components and utilities exist but are no longer used anywhere in the app. These add noise and can confuse developers who find them. For example, the original AddPatientForm component remains in the code alongside a newer form version, even though the new version is now in use
GitHub
. Unused files like this should be removed to avoid clutter.

Inconsistent Approaches: Some features are partially refactored into a new structure (like the documents feature and the patient registration form under src/features), while others still use the old structure. This inconsistency can trip up newcomers, as similar features are implemented in different ways. For example, patient document pages are being rewritten under a features/documents module, but tasks and notes are still only under the old pages/components structure.

Repetitive Logic in Forms: The code for forms (e.g., adding/editing patients, tasks, notes, medications) repeats common patterns (form state management, input fields, validation). There is an opportunity to extract reusable form components or hooks to handle these, rather than duplicating the logic in each page. This would reduce errors and make form changes easier.

Unused or Redundant Files (Clean-Up Targets)

After reviewing the repository, we identified several files that appear to be unused or ripe for removal due to redundancy:

Old Patient Form Components: There are two add-patient form components: AddPatientForm.tsx and AddPatientFormV2.tsx in src/components/patient/. The second was introduced as an improved version using a unified PatientRegistrationForm. The first (AddPatientForm) is now essentially legacy. It’s exported only as a “fallback” for a feature flag
GitHub
, but if the new form is the default, the old one can likely be retired. Similarly, the file structure under components/patient/patinet_form/... is an older version of the patient form logic that has been replicated under src/features/patient-details-input/. This duplication should be resolved by removing the outdated one.

Duplicate “Add Patient” Pages: There are two page components for adding a patient – AddPatientPage.tsx and AddPatient.tsx (both in src/pages). The app’s router currently uses AddPatientPage for the "/patients/add" route
GitHub
. The existence of AddPatient.tsx (which uses the newer form component) suggests an ongoing refactor. Once the refactor is complete, only one of these should remain. The extra file can be confusing; it’s advisable to consolidate into a single AddPatient page component (preferably using the new unified form) and delete the duplicate.

Unused Utility Functions: The code has an older patient-create.adapter.ts in src/components/patient/patinet_form/ with functions like mapSexToApi and normalizePathway
GitHub
. A newer toCreatePayload exists in src/features/patient-details-input/patient-create.adapter.ts for similar purposes
GitHub
GitHub
. Maintaining both is unnecessary. If nothing references the old adapter outside of legacy code, it should be removed, and any references updated to use the new one.

Tests and Config: There are a few test files (e.g., PatientRegistrationForm.smoke.test.tsx) present under components, but no test runner configured in the project (no mention of Jest/Vitest in package.json). These tests might not be running at all. If testing isn’t set up, these files are effectively unused. You might remove or properly integrate them by setting up a testing library, to avoid confusion for new contributors who see test files but no test execution.

Third-Party Libraries Not Used: In the package.json (not shown here, but mentioned in prior reviews), libraries like Recharts (a charting library) are included but no corresponding chart component is in use in the UI. Also, certain Radix UI components might be installed but not used. Unused dependencies aren’t code files, but removing them from the project will simplify the codebase and avoid the temptation to import unused heavy modules. This makes the project leaner for newcomers to install and understand (e.g., no wondering “where are the charts?” if none exist).

Identifying and removing unused files or code paths is a quick win to declutter the repository. It ensures developers focus only on the relevant code.

Redundant Pages and Components (Opportunities to Merge)

Several features have separate components for “Add” vs. “Edit” that largely duplicate each other’s UI and logic. Merging these or creating a common sub-component can simplify the code:

Patients – Add vs. Edit: Currently, Add Patient is handled by a page (and form) that collects patient info, and Edit Patient is a different page with nearly identical fields but also loads existing data. Much of the form UI (fields for name, age, gender, etc.) and validation is the same. The code duplication is evident – e.g., both implementations define sections like patient details, contact info, etc., in slightly different ways. A better approach is to use one reusable PatientForm component for both adding and editing a patient. This component can accept props like mode ("create" or "edit") and maybe an initial patient object for edit mode. In fact, the repository has a PatientRegistrationForm that is designed to handle both modes (it has a mode prop and logic for initial values)
GitHub
GitHub
. The plan should be to use this one form in both the Add Patient and Edit Patient pages, rather than maintaining two separate large form implementations. This way, any change to patient fields (say adding a new field or validation rule) only needs to be made once.

Medications – Add vs. Edit: The AddMedication.tsx and EditMedication.tsx pages are extremely similar
GitHub
GitHub
. Both have a form with fields for medication name, dose, route, frequency, start/end dates, priority, etc. The edit page simply pre-fills these fields and updates via a different API call. These could be combined into a single MedicationForm component or page. For example, you could have a single page MedicationFormPage that checks if there’s a medId in the URL: if yes, it loads the data and does an update on submit; if not, it does a create. Alternatively, factor out a child component <MedicationForm> that takes initialData and an onSubmit handler. Then AddMedication and EditMedication pages can both use it. This eliminates the duplicated JSX for the form fields.

Tasks – Add vs. Edit: Similarly, AddTask.tsx and EditTask.tsx repeat the same inputs (task title/description, type, date & time, assignee, priority) with minor differences in logic (creating a new task vs. updating an existing task)
GitHub
GitHub
. These can also be merged into one reusable form. A unified TaskForm could handle both scenarios by taking an optional existing task object. Consolidating them would mean any UI change (like adding a new task field) automatically applies to both add and edit flows.

Notes – Add vs. Edit: The AddNote page and EditNote page share the core fields (note category, author, content). The Edit page additionally handles loading existing content and attachments (images)
GitHub
GitHub
. Here too, the text input areas and category selector are duplicated. A shared NoteForm component could be created for the inputs, while the pages supply the surrounding logic (fetching existing note data in edit mode, or not in add mode). This would reduce repeating the JSX for category dropdown and content textarea.

Patient List Filtering Components: The “PatientsList” (patients overview page) likely shares elements with the Dashboard or other places where patient info is displayed. If there are repeating snippets (like a patient card or filtering logic), those could be extracted. For example, if the patient list page and maybe some other component both render a list of patient cards, ensure the PatientCard component is used consistently, instead of duplicating the markup for each patient entry. (A PatientCard component does exist in src/components/patient/PatientCard.tsx, so this is likely already considered. The key is to use it everywhere appropriate.)

Multiple Task Lists: There are separate pages for “All Tasks”, “Tasks Due Today”, “Urgent Alerts”, “Completed Today” etc. These pages have similar layouts (a header, maybe a filtered list of tasks). They currently use mock data and slightly different filtering. Over time, these could be refactored to a single Tasks page with dynamic filtering (e.g., a tab or filter selector for “due today”, “urgent”, etc.). For now, at least ensure any repeated JSX (like how a task is displayed as a card with title, due time, patient name) is a shared component. Indeed, the Tasks.tsx page defines a TaskCard internally
GitHub
GitHub
. That could be moved to a separate file and reused in TasksDue or other task pages, so the styling and behavior of task display stays consistent.

Merging and reusing components not only reduces code volume, it ensures a consistent user interface and behavior across the app. For instance, with a unified form for patients, the validation messages and field formats will be identical whether the user is adding or editing a patient, which is good for UX. For developers, it means learning one component instead of two for essentially the same task.

Repetitive Logic and Common Elements

Beyond whole pages, the codebase has repetitive patterns that can be refactored into reusable pieces:

Form Field Components: Many forms manually create input fields with labels and error messages. The project already uses some reusable UI form components (possibly from a UI library or custom abstractions, e.g. <FormField> and <FormItem> in the older AddPatientForm
GitHub
GitHub
). Ensure all forms use a common approach. If some forms are using plain <Input> with state, and others use React Hook Form or Zod for validation, it’s better to standardize. New developers will find it easier if there is one recommended way to create a form. Perhaps introduce a custom hook (like usePatientForm or generic useFormFields) for handling form state and submission. At the very least, create smaller components for repeating field structures (e.g., a <FormRow label="Name">...input...</FormRow> component) to avoid writing the same JSX for label-input-error across files.

API Calls and State: The data fetching pattern can be unified. Currently some pages use a simple api.patients.get() in useEffect and store data in local state (e.g., PatientsList, PatientDetail), while others might be moving to React Query for caching (the app has a QueryClient initialized, but direct use of useQuery isn’t prevalent yet). If possible, wrap common data fetching logic in custom hooks (for example, a usePatient(id) hook that internally uses React Query or fetches and caches a patient). This isn’t directly about file organization, but it improves maintainability: fewer places to change if the API or data handling changes. It also removes repetitive useEffect code across pages.

Layout Wrappers: Many pages have the same wrapper layout – a header, a main content area with padding, and a bottom bar. Right now, each page component repeats this structure. For example, we see many times: <div className="min-h-screen bg-background pb-20"> <Header .../> ... <BottomBar/> </div> in various files
GitHub
GitHub
. This can be abstracted into a higher-order component or layout component. You could create a PageLayout component that takes children and maybe a title/back button, and it automatically wraps them with the header and footer. Then pages become more concise and consistent. A new developer reading a page component can focus on the unique content, not the chrome around it.

Conditional Feature Flags: The code uses a feature flag for the patient form (V1 vs V2)
GitHub
. If the new form is stable, consider removing the flag and the old path. Feature flags are useful in development, but leaving both code paths in production long-term adds complexity. It’s better for maintainability to remove the dead code once a feature is fully rolled out. This applies to any similar toggles in the app. Keep the codebase as single-path as possible to avoid confusion (unless you truly plan to support two versions in parallel, which is rare on the frontend).

By eliminating repetitive code and centralizing common logic, we reduce the surface area that a newcomer must understand. It also lowers the chance of inconsistencies (for example, two different pages filtering patients slightly differently – if one shared utility is used, they will both behave the same).

Proposed Feature-Based Structure

To make the project more intuitive, reorganize the files by feature/domain. This means each major feature (patients, tasks, notes, etc.) gets its own folder containing everything related: pages, subcomponents, styles, and perhaps even tests and state management for that feature. This contrasts with the current split where all pages live together and all components in another folder.

Suggested Folder Layout:

src/  
  features/  
    patients/  
      PatientList.tsx         (Patients list page/component)  
      PatientDetail.tsx       (Patient detail page)  
      PatientForm.tsx         (Add/Edit patient form component)  
      PatientCard.tsx         (UI component for patient info card)  
      index.ts                (optional: re-export components)  
      ... (any other patient-specific utilities or sub-components)  
    tasks/  
      TasksPage.tsx           (All tasks or main tasks page)  
      TasksDuePage.tsx        (Tasks due today page)  
      TaskForm.tsx            (Add/Edit task form component)  
      TaskCard.tsx            (UI for a single task item)  
      ...  
    notes/  
      NotesPage.tsx           (if there’s a main notes list, or could be under patients)  
      NoteDetail.tsx          (for viewing a single note, if exists)  
      NoteForm.tsx            (Add/Edit note component)  
      ...  
    medications/  
      MedicationsPage.tsx     (list of patient’s medications, if separate)  
      MedicationForm.tsx      (Add/Edit medication form)  
      ...  
    documents/  
      DocumentsPage.tsx       (container or main documents feature page)  
      DocumentsFolder.tsx     (sub-page for a folder, as in current features/documents)  
      ...  
  components/  
    ui/                      (basic reusable UI elements – already in place, e.g., Button, Input)  
    layout/                  (layout components like Header, BottomBar – could also be in a core folder)  
  hooks/                    (shared hooks if any, like useToast, etc.)  
  lib/                      (shared utilities and API client as currently structured)  
  types/                    (Type definitions for API models, etc.)  


In the above scheme, each feature folder encapsulates that feature’s pages and components. For example, a new developer tasked with working on patient-related screens can go straight to src/features/patients/ and find everything relevant. This reduces the need to hop between pages/ and components/ folders for related code. It’s also aligned with “atomic design” to an extent: you can still keep truly universal UI atoms in components/ui, but more complex “organisms” that are specific to a domain (like a PatientCard or TaskList) live with their domain.

Atomic Design Consideration: If desired, you could further break down components in each feature into sub-folders like components/ (for smaller reusable parts) and pages/ (for page-level components). Some teams use atomic terminology (atoms, molecules, organisms), but an easier approach for newcomers is often descriptive names like components/common/ vs components/patient/. The key is to avoid one giant “components” folder with no grouping – grouping by feature or purpose is what improves clarity.

For example, within features/patients/, you might structure:

pages/PatientList.tsx (maybe the page component for listing patients),

pages/PatientDetail.tsx,

components/PatientForm.tsx,

components/PatientCard.tsx, etc.
This way, if someone is working on patient forms, they see it next to patient pages, reinforcing the relationship.

The repository has already started moving in this direction with a features/documents folder and features/patient-details-input (for the new patient form). Our recommendation is to continue this migration for all major features:

Move files from src/pages and src/components into their respective feature folder. For instance, all patient-related files go to features/patients. Update import paths accordingly (the project’s use of @/ alias can help; just make sure it points to src so new paths are recognized).

Remove or merge duplicate files during this move (for example, don’t carry over both AddPatientPage.tsx and AddPatient.tsx – choose one implementation). Use the new unified components in the feature folder.

For smaller shared components used across features (like Header, or a generic ConfirmDeleteDialog perhaps), keep them in a components/layout or components/common folder. This separation ensures the features folders contain mostly feature-specific logic and UI, keeping cross-cutting concerns in a central place.

New developers unfamiliar with frontend concepts will benefit from this structure because it mirrors the application’s features. Instead of needing to know that “pages” go here and “components” there, they can think in terms of the product: “I need to change how we add a patient. Let me go to the patient feature folder and find an Add or Form component.” It’s a more natural mapping to the actual screens and user flows. Each folder can even include a README or comments explaining how that feature’s code is organized, which is an extra onboarding help.

Specific Improvements and Examples

Here are some concrete improvements that illustrate the above points:

Merge Add/Edit Patient Pages: Use the PatientRegistrationForm (currently in features/patient-details-input/PatientRegistrationForm.tsx) inside both the Add Patient route and Edit Patient route. You can pass an existing patient object to pre-fill the form for editing. By doing this, you could delete hundreds of lines of repetitive code in EditPatient.tsx that manually manages form state and input fields (all of which the unified form already handles). For instance, instead of two separate components, you might have:

// New AddEditPatientPage.jsx (example)
import PatientForm from '@/features/patients/PatientForm';
export default function AddEditPatientPage() {
  const { id } = useParams();  // if id exists, it's edit mode
  const isEdit = Boolean(id);
  const [initialData, setInitialData] = useState(null);
  
  useEffect(() => {
    if (isEdit) {
      api.patients.get(id).then(data => setInitialData(data));
    }
  }, [id]);
  
  const handleSubmit = async (formData) => {
    if (isEdit) {
      await api.patients.update(id, formData);
    } else {
      await api.patients.create(formData);
    }
    navigate(isEdit ? `/patients/${id}` : `/patients`);
  };
  
  return (
    <div>
      <Header title={isEdit ? "Edit Patient" : "Add Patient"} ... />
      <PatientForm initialData={initialData} onSubmit={handleSubmit} />
    </div>
  );
}


The above pseudo-code shows a single component handling both add and edit depending on whether an id is present. The actual implementation can vary, but the concept is one component for both, using one form internally. This change would dramatically reduce duplicate logic like handleInputChange functions and separate schema definitions in multiple places. It also means if you add a new field (say, “Middle Name”), you add it in one form component and both add & edit will have it.

Create Reusable Form Components: The form fields for medications, tasks, etc., often have common elements like a dropdown for priority (e.g., low/medium/high). Consider making a small component <PrioritySelect value={...} onChange={...} /> that encapsulates the select input for priority. Then use <PrioritySelect> in all forms that need it. This way, if the priority options or styling need to change, it’s done in one place. The same can be done for date-time pickers or other repeated input patterns. In the AddTask form, for example, the date and time inputs could be combined into a small <DateTimePicker> component or just reused in EditTask, so both have identical behavior for selecting due date/time
GitHub
GitHub
.

Use a Single Source of Truth for Patient State: In PatientDetail, after an edit, they refetch the patient data when the page regains focus
GitHub
. If you unify forms and perhaps integrate React Query, you could avoid manual refetching. For example, using React Query’s cache, the EditPatient form could invalidate or update the “patient” query on save, and PatientDetail would automatically show updated data (or at least be simpler to refresh). This reduces the number of explicit effect handlers and ensures consistency. While this is a performance/data flow improvement, it also simplifies the code needed on the PatientDetail page (no need for event listeners for visibility if the data library handles cache updates).

Better Documentation and Onboarding Aids: Although not code structure per se, adding comments or brief docs in each feature folder will help non-frontend folks. For example, a top comment in the patients/PatientForm.tsx file could explain: “// This component is used for both adding and editing a patient. It expects either to be given initial patient data (for edit) or used empty for new patients. It handles form validation with Zod, and calls onSubmit with a Patient object.” This kind of note can greatly help someone unfamiliar with React forms to quickly grasp the intent. Similarly, clarify the purpose of any complex custom hooks or utilities with comments. A clean structure combined with clear comments is ideal for new developers.

Conclusion

By reorganizing the codebase around features, removing unused code, and unifying duplicate components, the Clinical Canvas frontend will become cleaner, DRYer (Don’t Repeat Yourself), and easier to navigate. A new developer with limited frontend experience should be able to guess that anything to do with patients is in a “patients” folder, tasks in “tasks”, and so on, making the learning curve much gentler. The reduction in duplicate code also means fewer places to debug or update when changes are needed. Overall, these changes will improve maintainability and scalability of the codebase, allowing the team to deliver features faster and with more confidence.

Moving forward, continue to audit for dead code regularly and promote reusability. Encourage a practice where, if a developer finds themselves copying a block of JSX or logic to another file, they instead refactor it into a shared component or function. Over time, this will cultivate a more modular and robust codebase. The suggested structure and refactoring will set a strong foundation for that, making the Clinical Canvas frontend well-organized and easier for everyone to work on.




